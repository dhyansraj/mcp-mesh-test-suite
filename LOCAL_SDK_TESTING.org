#+TITLE: Local SDK Testing Implementation Plan
#+AUTHOR: Claude
#+DATE: 2026-01-20
#+STARTUP: overview

* Overview

This document describes the implementation plan for testing MCP Mesh SDK packages
from local source code instead of pulling from PyPI/npm. This enables:

- CI testing against unreleased SDK changes
- Faster iteration during development
- Offline testing capability
- Consistent builds across test runs

* Architecture

** Current State

#+begin_src
┌─────────────────┐     ┌─────────────────┐
│  Integration    │────▶│  PyPI / npm     │
│  Suite          │     │  (published)    │
└─────────────────┘     └─────────────────┘
#+end_src

Tests pull SDK packages from the internet using version strings in:
- =requirements.txt= (Python agents)
- =package.json= (TypeScript agents)

Problems:
- Network dependency during tests
- Can't test unreleased changes
- Version placeholder =__SDK_VERSION__= needs sed replacement

** Proposed State

#+begin_src
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  SDK Source     │────▶│  Build Suite    │────▶│  SDK Image      │
│  - mcp-mesh-py  │     │  - pip wheel    │     │  /wheels/*.whl  │
│  - mcp-mesh-ts  │     │  - npm pack     │     │  /packages/*.tgz│
└─────────────────┘     └─────────────────┘     └─────────────────┘
                                                        │
                                                        ▼
                                                ┌─────────────────┐
                                                │  Integration    │
                                                │  Suite          │
                                                │  (mode=local)   │
                                                └─────────────────┘
#+end_src

* Components

** 1. Source Build Suite (=src-tests/=)

A test suite that builds all MCP Mesh packages from source code.
Located at: =src-tests/=

*** Directory Structure

#+begin_src
src-tests/
├── config.yaml
├── Dockerfile                 # Build environment with Go, Rust, Python, Node
├── README.md
├── global/
│   └── routines.yaml
└── suites/
    └── build/
        ├── tc01_build_meshctl/
        │   └── test.yaml      # Build Go CLI
        ├── tc02_build_rust_core/
        │   └── test.yaml      # Build Rust core (maturin)
        ├── tc03_build_python_sdk/
        │   └── test.yaml      # Build Python SDK wheel
        ├── tc04_build_typescript_sdk/
        │   └── test.yaml      # Build TypeScript SDK tarball
        └── tc05_verify_artifacts/
            └── test.yaml      # Verify all artifacts
#+end_src

*** Source Code

The mcp-mesh source is cloned at: =mcp-mesh/=

Structure:
- =cmd/meshctl/= - Go CLI source
- =src/runtime/core/= - Rust core with Python bindings
- =src/runtime/python/= - Python SDK
- =src/runtime/typescript/= - TypeScript SDK

*** config.yaml

#+begin_src yaml
suite:
  name: "SDK Build Suite"
  mode: docker

sdk:
  python:
    repo: "https://github.com/anthropics/mcp-mesh-python.git"
    branch: "${SDK_PYTHON_BRANCH:-main}"
    # Or use local mount
    local_path: "/src/mcp-mesh-python"
  typescript:
    repo: "https://github.com/anthropics/mcp-mesh-ts.git"
    branch: "${SDK_TYPESCRIPT_BRANCH:-main}"
    local_path: "/src/mcp-mesh-ts"

output:
  wheels_dir: "/wheels"
  packages_dir: "/packages"
#+end_src

*** tc01_python_wheel/test.yaml

#+begin_src yaml
name: "Build Python SDK Wheel"
description: "Build mcp-mesh Python wheel from source"
tags:
  - build
  - python

test:
  - name: "Check SDK source"
    handler: shell
    command: |
      if [ -d "/src/mcp-mesh-python" ]; then
        echo "Using mounted source"
        cp -r /src/mcp-mesh-python /build/
      else
        echo "Cloning from repo"
        git clone ${config.sdk.python.repo} /build/mcp-mesh-python
        cd /build/mcp-mesh-python
        git checkout ${config.sdk.python.branch}
      fi
    capture: source_output

  - name: "Install build dependencies"
    handler: shell
    command: "pip install build wheel"

  - name: "Build wheel"
    handler: shell
    command: |
      cd /build/mcp-mesh-python
      pip wheel . -w /wheels --no-deps
    capture: build_output

  - name: "List built wheels"
    handler: shell
    command: "ls -la /wheels/"
    capture: wheel_list

assertions:
  - expr: ${captured.wheel_list} contains 'mcp_mesh'
    message: "mcp-mesh wheel should be created"
  - expr: ${captured.wheel_list} contains '.whl'
    message: "Wheel file should have .whl extension"
#+end_src

*** tc02_typescript_package/test.yaml

#+begin_src yaml
name: "Build TypeScript SDK Package"
description: "Build @mcpmesh/sdk npm tarball from source"
tags:
  - build
  - typescript

test:
  - name: "Check SDK source"
    handler: shell
    command: |
      if [ -d "/src/mcp-mesh-ts" ]; then
        echo "Using mounted source"
        cp -r /src/mcp-mesh-ts /build/
      else
        echo "Cloning from repo"
        git clone ${config.sdk.typescript.repo} /build/mcp-mesh-ts
        cd /build/mcp-mesh-ts
        git checkout ${config.sdk.typescript.branch}
      fi
    capture: source_output

  - name: "Install dependencies"
    handler: shell
    command: "cd /build/mcp-mesh-ts && npm install"

  - name: "Build package"
    handler: shell
    command: "cd /build/mcp-mesh-ts && npm run build"

  - name: "Create tarball"
    handler: shell
    command: "cd /build/mcp-mesh-ts && npm pack --pack-destination /packages"
    capture: pack_output

  - name: "List built packages"
    handler: shell
    command: "ls -la /packages/"
    capture: package_list

assertions:
  - expr: ${captured.package_list} contains 'mcpmesh-sdk'
    message: "@mcpmesh/sdk tarball should be created"
  - expr: ${captured.package_list} contains '.tgz'
    message: "Package should have .tgz extension"
#+end_src

** 2. Custom Handlers

New handlers in tsuite that support local/published modes.

*** Handler: =pip-install=

Location: =tsuite/tsuite/handlers/pip_install.py=

#+begin_src python
"""
pip-install handler - Install Python dependencies with local package support.

Usage in test.yaml:
  - name: "Install dependencies"
    handler: pip-install
    path: /workspace/agent1
    venv: /workspace/.venv      # Optional, defaults to /workspace/.venv
"""

import os
import subprocess
from pathlib import Path


def handle(step: dict, context: dict) -> dict:
    """
    Install Python dependencies from requirements.txt.

    Checks config.packages.mode:
    - "local": Uses --find-links with /wheels directory
    - "published": Normal pip install from PyPI
    - "auto": Auto-detect (local if /wheels exists and non-empty)
    """
    path = step.get("path", "/workspace")
    venv = step.get("venv", "/workspace/.venv")
    config = context.get("config", {})

    packages_config = config.get("packages", {})
    mode = packages_config.get("mode", "auto")
    wheels_dir = packages_config.get("local", {}).get("wheels_dir", "/wheels")

    # Auto-detect mode
    if mode == "auto":
        if os.path.exists(wheels_dir) and os.listdir(wheels_dir):
            mode = "local"
        else:
            mode = "published"

    pip_bin = f"{venv}/bin/pip"
    requirements_file = Path(path) / "requirements.txt"

    if not requirements_file.exists():
        return {"status": "skipped", "message": "No requirements.txt found"}

    # Build command
    cmd = [pip_bin, "install", "-r", str(requirements_file)]

    if mode == "local":
        cmd.extend(["--find-links", wheels_dir])
        # Prefer local packages over PyPI
        cmd.append("--no-index")
        # But allow fallback for other dependencies
        cmd.extend(["--extra-index-url", "https://pypi.org/simple/"])

    result = subprocess.run(cmd, capture_output=True, text=True)

    return {
        "status": "success" if result.returncode == 0 else "failed",
        "mode": mode,
        "stdout": result.stdout,
        "stderr": result.stderr,
        "exit_code": result.returncode
    }
#+end_src

*** Handler: =npm-install=

Location: =tsuite/tsuite/handlers/npm_install.py=

#+begin_src python
"""
npm-install handler - Install Node.js dependencies with local package support.

Usage in test.yaml:
  - name: "Install dependencies"
    handler: npm-install
    path: /workspace/agent1
"""

import json
import os
import subprocess
from pathlib import Path


def handle(step: dict, context: dict) -> dict:
    """
    Install Node.js dependencies from package.json.

    Checks config.packages.mode:
    - "local": Replaces @mcpmesh/* versions with file: references
    - "published": Normal npm install from registry
    - "auto": Auto-detect (local if /packages exists and non-empty)
    """
    path = step.get("path", "/workspace")
    config = context.get("config", {})

    packages_config = config.get("packages", {})
    mode = packages_config.get("mode", "auto")
    packages_dir = packages_config.get("local", {}).get("packages_dir", "/packages")

    # Auto-detect mode
    if mode == "auto":
        if os.path.exists(packages_dir) and os.listdir(packages_dir):
            mode = "local"
        else:
            mode = "published"

    package_json_path = Path(path) / "package.json"

    if not package_json_path.exists():
        return {"status": "skipped", "message": "No package.json found"}

    # If local mode, modify package.json to use file: references
    if mode == "local":
        with open(package_json_path) as f:
            package_data = json.load(f)

        modified = False
        for dep_type in ["dependencies", "devDependencies"]:
            deps = package_data.get(dep_type, {})
            for pkg_name, version in deps.items():
                if pkg_name.startswith("@mcpmesh/"):
                    # Find matching tarball
                    tarball = find_tarball(packages_dir, pkg_name)
                    if tarball:
                        deps[pkg_name] = f"file:{tarball}"
                        modified = True

        if modified:
            with open(package_json_path, "w") as f:
                json.dump(package_data, f, indent=2)

    # Run npm install
    result = subprocess.run(
        ["npm", "install"],
        cwd=path,
        capture_output=True,
        text=True
    )

    return {
        "status": "success" if result.returncode == 0 else "failed",
        "mode": mode,
        "stdout": result.stdout,
        "stderr": result.stderr,
        "exit_code": result.returncode
    }


def find_tarball(packages_dir: str, package_name: str) -> str | None:
    """Find tarball for a package in the packages directory."""
    # @mcpmesh/sdk -> mcpmesh-sdk-*.tgz
    normalized = package_name.replace("@", "").replace("/", "-")

    for file in os.listdir(packages_dir):
        if file.startswith(normalized) and file.endswith(".tgz"):
            return os.path.join(packages_dir, file)

    return None
#+end_src

** 3. Integration Suite Config Changes

*** config.yaml additions

#+begin_src yaml
# Integration suite config.yaml

packages:
  # Mode: "local", "published", or "auto"
  # - local: Use /wheels and /packages from SDK image
  # - published: Pull from PyPI/npm
  # - auto: Auto-detect based on presence of /wheels, /packages
  mode: "auto"

  # Published versions (used when mode=published or as fallback)
  cli_version: "0.8.0-beta.9"
  sdk_python_version: "0.8.0-beta.9"
  sdk_typescript_version: "0.8.0-beta.9"

  # Local paths (used when mode=local)
  local:
    wheels_dir: "/wheels"
    packages_dir: "/packages"
#+end_src

*** Updated global routines

#+begin_src yaml
# integration/global/routines.yaml

routines:
  # Install Python agent dependencies
  install_python_deps:
    description: "Install Python dependencies with local/published support"
    params:
      path:
        type: string
        required: true
    steps:
      - handler: pip-install
        path: ${params.path}
        venv: /workspace/.venv

  # Install TypeScript agent dependencies
  install_typescript_deps:
    description: "Install TypeScript dependencies with local/published support"
    params:
      path:
        type: string
        required: true
    steps:
      - handler: npm-install
        path: ${params.path}
#+end_src

** 4. Docker Image Flow

*** Build Suite Dockerfile

#+begin_src dockerfile
# build-suite/Dockerfile.base
FROM python:3.11-slim

# Install Node.js
RUN apt-get update && apt-get install -y curl git \
    && curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
    && apt-get install -y nodejs \
    && rm -rf /var/lib/apt/lists/*

# Create output directories
RUN mkdir -p /wheels /packages /build /src

WORKDIR /build
#+end_src

*** SDK Image (output of build-suite)

#+begin_src dockerfile
# Generated/output image structure
#
# /wheels/
#   └── mcp_mesh-0.8.0b9-py3-none-any.whl
# /packages/
#   └── mcpmesh-sdk-0.8.0-beta.9.tgz
#+end_src

*** Integration Suite Usage

#+begin_src dockerfile
# integration/Dockerfile
# When using local SDK:
FROM sdk-local:latest AS sdk

FROM tsuite-base:latest
COPY --from=sdk /wheels /wheels
COPY --from=sdk /packages /packages

# ... rest of integration setup
#+end_src

* CLI Workflow

** Build SDK packages from source

#+begin_src bash
# Option 1: Clone and build
tsuite --suite build-suite

# Option 2: Mount local source
tsuite --suite build-suite \
  -v /path/to/mcp-mesh-python:/src/mcp-mesh-python \
  -v /path/to/mcp-mesh-ts:/src/mcp-mesh-ts

# Output: sdk-local:latest image with /wheels and /packages
#+end_src

** Run integration tests with local SDK

#+begin_src bash
# Use the SDK image
tsuite --suite integration \
  --base-image sdk-local:latest \
  --set packages.mode=local
#+end_src

** Run integration tests with published SDK

#+begin_src bash
# Use published packages (default)
tsuite --suite integration --set packages.mode=published

# Or just
tsuite --suite integration
#+end_src

* Implementation Tasks

** Phase 1: Custom Handlers
- [ ] Create =tsuite/tsuite/handlers/pip_install.py=
- [ ] Create =tsuite/tsuite/handlers/npm_install.py=
- [ ] Register handlers in handler registry
- [ ] Add tests for handlers

** Phase 2: Build Suite
- [ ] Create =build-suite/= directory structure
- [ ] Write =config.yaml=
- [ ] Write =tc01_python_wheel/test.yaml=
- [ ] Write =tc02_typescript_package/test.yaml=
- [ ] Write =tc03_verify_artifacts/test.yaml=
- [ ] Create =Dockerfile.base=

** Phase 3: Integration Suite Updates
- [ ] Update =config.yaml= with packages.mode config
- [ ] Update global routines to use new handlers
- [ ] Update test cases to use =pip-install= / =npm-install= handlers
- [ ] Remove scattered sed commands for version replacement

** Phase 4: CLI Integration
- [ ] Add =--base-image= flag to tsuite CLI
- [ ] Add =--set= flag for config overrides
- [ ] Add =--output-image= flag for build-suite
- [ ] Document workflow in README

* Testing the Implementation

** Unit tests for handlers

#+begin_src python
# tests/test_pip_install_handler.py

def test_local_mode_uses_find_links():
    """Verify --find-links is used when mode=local"""
    pass

def test_auto_mode_detects_wheels():
    """Verify auto mode detects /wheels directory"""
    pass

def test_published_mode_normal_install():
    """Verify normal pip install when mode=published"""
    pass
#+end_src

** Integration test

#+begin_src bash
# Test the full flow
cd mcp-mesh-test-suite

# 1. Build SDK image
tsuite --suite build-suite \
  -v ../mcp-mesh-python:/src/mcp-mesh-python \
  -v ../mcp-mesh-ts:/src/mcp-mesh-ts

# 2. Run one integration test with local SDK
tsuite --suite integration \
  --base-image sdk-local:latest \
  --set packages.mode=local \
  --filter tc01_python_agent
#+end_src

* Bug Summary (Found During Testing)

These bugs were found while testing LLM integration with SDK 0.8.0-beta.9:

** Bug 1: @mesh.llm requires filter for LLM injection
- Severity: High
- Without =filter= parameter, =llm= parameter stays =None=
- Workaround: Add =filter=[{"tags": ["math"]}]= or similar

** Bug 2: OpenAI structured output returns schema
- Severity: High
- Affects: Python and TypeScript
- Returns schema metadata instead of actual values
- Works fine with =-> str= return type

** Bug 3: Gemini TypeScript prompt format error
- Severity: High
- Error: =AI_InvalidPromptError: messages do not match ModelMessage[] schema=
- Gemini Python works fine

** Compatibility Matrix

| Provider | Python | TypeScript |
|----------|--------|------------|
| Claude   | OK     | OK         |
| OpenAI   | FAIL*  | FAIL*      |
| Gemini   | OK     | FAIL       |

*OpenAI works with =-> str=, fails with Pydantic models
