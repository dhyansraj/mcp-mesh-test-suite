#+TITLE: tsuite Architecture Refactor - Simplified
#+AUTHOR: Claude & Dhyanraj
#+DATE: 2026-01-21
#+STARTUP: overview

* Goal

Simplify tsuite by merging RunnerServer into API server, enabling single source
of truth and parallel test execution in docker mode.

* Key Principle: CLI Owns the Workflow

The CLI is the single orchestrator. API server is just:
1. A database/state store
2. SSE broadcaster for UI
3. A "dumb launcher" that invokes CLI with parameters

#+begin_src text
Eventual Consistency:
- UI triggers run → API launches CLI → CLI creates run via API → UI sees run
- Milliseconds delay, but clean separation of concerns
#+end_src

* Current vs Target

** Current Architecture (Problematic)

#+begin_src text
┌─────────────┐     ┌──────────────┐     ┌────────────┐
│ CLI         │────▶│ RunnerServer │     │ API Server │
│             │     │ (9998)       │     │ (9999)     │
└─────────────┘     └──────────────┘     └────────────┘
       │                   ▲                   ▲
       │                   │                   │
       └──────────────────►│  Container        │
                           └───────────────────┘
                           CLI forwards SSE events

Problems:
- Two servers (port 9998 hardcoded = conflicts)
- CLI is orchestrator AND event forwarder
- No parallel execution
- Complex state flow
#+end_src

** Target Architecture

#+begin_src text
┌─────────────────────────────────────────────────────────────────────────┐
│  UI: Click "Run Tests"                                                  │
│  POST /api/suites/1/run {tc: "uc01/tc01"}                              │
└────────────────────────────────┬────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  API Server: Dumb Launcher                                              │
│  - Just builds CLI command from request params                          │
│  - subprocess.Popen(["tsuite", "--tc", "uc01/tc01", "--api-url", ...]) │
│  - Returns {started: true, pid: 12345}                                  │
│  - Does NOT create run_id (CLI will do that)                            │
└────────────────────────────────┬────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  CLI: Owns the Workflow                                                 │
│                                                                         │
│  1. Ensure API server running (health check, start if needed)           │
│  2. Read YAML, discover tests                                           │
│  3. POST /api/runs → create run in DB, get run_id                       │
│  4. Worker pool executes tests (1 for standalone, N for docker)         │
│     - PATCH /api/runs/{id}/tests/{test_id} {status: running}            │
│     - Execute in subprocess (standalone) or container (docker)          │
│     - Container calls API for /config, /state, /capture                 │
│     - PATCH /api/runs/{id}/tests/{test_id} {status: passed/failed}      │
│  5. POST /api/runs/{id}/complete                                        │
└────────────────────────────────┬────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  API Server: Emits SSE on Each PATCH                                    │
│  - PATCH triggers sse_manager.emit()                                    │
│  - UI receives updates via EventSource(/api/events)                     │
└─────────────────────────────────────────────────────────────────────────┘

Benefits:
- Single server (no port conflicts)
- CLI owns workflow (same code path: terminal or API-triggered)
- Eventual consistency (UI sees run when CLI creates it)
- Direct updates (containers → API)
- Worker pool enables parallelism
#+end_src

* Design Decisions

| Aspect              | Decision                                               |
|---------------------+--------------------------------------------------------|
| Run creation        | CLI creates run via API (not API pre-creating)         |
| API server role     | DB + SSE + launcher (dumb, no workflow logic)          |
| CLI role            | Read YAML, create run, execute, update status          |
| API server startup  | CLI starts if not running, or run standalone           |
| Parallelism         | Standalone = sequential only; Docker = configurable    |
| Status reporting    | CLI reports final status; API is idempotent            |
| Crash handling      | CLI detects subprocess/container death, reports crash  |
| Worker pool         | Local to CLI process                                   |

* Component Responsibilities

| Component      | Responsibilities                                            |
|----------------+-------------------------------------------------------------|
| API Server     | - Serve DB operations (CRUD for runs, tests, suites)        |
|                | - Broadcast SSE events on state changes                     |
|                | - Serve /config, /state, /capture for test containers       |
|                | - Launch CLI subprocess when triggered from UI              |
|----------------+-------------------------------------------------------------|
| CLI            | - Read YAML config and discover tests                       |
|                | - Ensure API server is running                              |
|                | - Create run via POST /api/runs                             |
|                | - Execute tests (subprocess or docker)                      |
|                | - Update status via PATCH /api/runs/{id}/tests/{test_id}    |
|                | - Complete run via POST /api/runs/{id}/complete             |
|----------------+-------------------------------------------------------------|
| UI/Dashboard   | - Subscribe to SSE for live updates                         |
|                | - Trigger runs via POST /api/suites/{id}/run                |
|                | - Display run/test status                                   |

* Implementation Phases

** PHASE 1: Merge RunnerServer into API Server [8/8]

Move all RunnerServer endpoints into API server under /api/runner/* prefix.

*** DONE Move /config endpoint
CLOSED: [2026-01-21]
- Current: RunnerServer serves config to containers
- Target: API server at /api/runner/config
- Added /api/runner/config and /api/runner/config/<path> in server.py

*** DONE Move /routine/<scope>/<name> endpoint
CLOSED: [2026-01-21]
- Current: RunnerServer at /routine/global/setup_environment
- Target: API server at /api/runner/routine/<scope>/<name>
- Added /api/runner/routine/<scope>/<name> and /api/runner/routines in server.py

*** DONE Move /state/<test_id> endpoints (GET/POST)
CLOSED: [2026-01-21]
- Current: RunnerServer manages test state
- Target: API server at /api/runner/state/<test_id>
- Added /api/runner/state/<test_id> (GET/POST) in server.py

*** DONE Move /capture/<test_id> endpoint (POST)
CLOSED: [2026-01-21]
- Current: RunnerServer stores captured variables
- Target: API server at /api/runner/capture/<test_id>
- Added /api/runner/capture/<test_id> (POST) in server.py

*** DONE Move /progress/<test_id> endpoints (GET/POST)
CLOSED: [2026-01-21]
- Current: RunnerServer tracks step progress
- Target: API server at /api/runner/progress/<test_id>
- Added /api/runner/progress/<test_id> (GET/POST) in server.py

*** DONE Move /context/<test_id> endpoint (GET)
CLOSED: [2026-01-21]
- Current: RunnerServer provides full test context
- Target: API server at /api/runner/context/<test_id>
- Added /api/runner/context/<test_id> (GET) in server.py

*** DONE Add run_id association to runner endpoints
CLOSED: [2026-01-21]
- Runner endpoints need to know which run they're serving
- Pass run_id via header or query param: ?run_id=xxx
- Added run_id query param support (optional, for future use)

*** DONE Update container SERVER_URL
CLOSED: [2026-01-21]
- Current: http://host.docker.internal:9998
- Target: http://host.docker.internal:9999
- Updated cli.py to pass API server URL (9999) to DockerExecutor
- Updated client.py to use /api/runner/* endpoints
- Old endpoints kept for backward compatibility

** PHASE 2: Update CLI [6/6]

CLI owns the workflow. Remove RunnerServer, add API integration.

*** DONE Add health_check() function
CLOSED: [2026-01-21]
- Added health_check(api_url, timeout) to cli.py
- Returns True if server responds to /health endpoint

*** DONE Add ensure_api_server() function
CLOSED: [2026-01-21]
- Added ensure_api_server(port, timeout) to cli.py
- Starts API server in background if not running
- Waits for server to be ready with retry loop

*** DONE CLI creates run via API
CLOSED: [2026-01-21]
- Added create_run_via_api() function
- Added start_run_via_api() function
- Added complete_run_via_api() function
- Added update_test_status_via_api() function

*** DONE Remove RunnerServer class from cli.py
CLOSED: [2026-01-21]
- Removed RunnerServer import
- run_local_mode and run_docker_mode no longer use RunnerServer
- API server URL (port 9999) used directly

*** DONE Update run_docker_mode()
CLOSED: [2026-01-21]
- Removed RunnerServer context manager
- Uses http://host.docker.internal:9999 for containers
- Added api_url parameter

*** DONE Update run_local_mode()
CLOSED: [2026-01-21]
- Removed RunnerServer context manager
- Uses API server URL directly
- Added api_url parameter

** PHASE 3: Simplify API Server's Run Endpoint [2/2]

API server becomes a dumb launcher.

*** DONE Simplify api_run_suite endpoint
CLOSED: [2026-01-21]
- Removed --port flag (RunnerServer no longer used)
- Added --api-url parameter for CLI callback
- Added support for tags and skip_tags parameters
- Fallback to sys.executable if venv not found
- Cleaned up debug logging

*** DONE Remove run_id pre-creation from API
CLOSED: [2026-01-21]
- Verified API never pre-created run_id (was already correct)
- CLI creates run_id via POST /api/runs
- Eventual consistency pattern working as designed:
  1. UI calls POST /api/suites/{id}/run
  2. api_run_suite launches CLI subprocess
  3. CLI calls POST /api/runs to create run in DB
  4. CLI updates status via PATCH /api/runs/{id}/tests/{test_id}
  5. CLI completes via POST /api/runs/{id}/complete

** PHASE 4: Worker Pool [5/5]

Enable parallel test execution in docker mode.

*** DONE Add execution config to schema
CLOSED: [2026-01-21]
- Uses existing config.defaults.parallel for max_workers
- Uses existing config.defaults.timeout for per-test timeout
- Default: parallel=1 (sequential), timeout=300s

*** DONE Create WorkerPool class
CLOSED: [2026-01-21]
- Added WorkerPool class with ThreadPoolExecutor
- Supports context manager pattern (with statement)
- Added map_unordered() for as_completed results
- Added TestTimeoutError exception class

*** DONE Update run_docker_mode() to use pool
CLOSED: [2026-01-21]
- Reads max_workers from config.defaults.parallel
- Uses WorkerPool for parallel execution when max_workers > 1
- Sequential fallback when max_workers == 1
- Extracted execute_single_test() helper for parallel execution
- Results collected as they complete (unordered)

*** DONE Force max_workers=1 in standalone mode
CLOSED: [2026-01-21]
- run_local_mode always uses sequential execution
- Added docstring clarifying this is intentional (shared filesystem)
- No WorkerPool used in standalone mode

*** DONE Add test execution timeout
CLOSED: [2026-01-21]
- Added execute_with_timeout() function
- Wraps test execution with configurable timeout
- Raises TestTimeoutError on timeout
- Timeout read from config.defaults.timeout (default 300s)

** PHASE 5: Idempotent Status Updates [4/4]

Ensure status updates are safe for retries and race conditions.

*** DONE Add 'crashed' to TestStatus enum
CLOSED: [2026-01-21]
#+begin_src python
class TestStatus(enum.Enum):
    PENDING = "pending"
    RUNNING = "running"
    PASSED = "passed"
    FAILED = "failed"
    CRASHED = "crashed"    # NEW: subprocess/container died unexpectedly
    SKIPPED = "skipped"
#+end_src

*** DONE Implement idempotent update logic
CLOSED: [2026-01-21]
- Added TERMINAL_STATES constant in models.py
- Added idempotent check in update_test_status() and update_test_result()
- Terminal states (passed/failed/crashed/skipped) cannot be overwritten
- Updated SSE emission to include CRASHED status

*** DONE CLI reports 'crashed' on unexpected death
CLOSED: [2026-01-21]
- execute_single_test() catches unexpected exceptions
- Reports CRASHED status with error message "Container/process crashed: {e}"
- Uses try/except around execute_with_timeout() call

*** DONE Handle timeout as failure
CLOSED: [2026-01-21]
- Timeout raises TestTimeoutError, caught separately from crashes
- Reports FAILED status (not CRASHED) for timeouts
- Error message: "Test exceeded {timeout}s timeout"

** PHASE 6: Cleanup [3/4]

Remove old code, update documentation.

*** DONE Remove RunnerServer class entirely
CLOSED: [2026-01-21]
- Deleted RunnerServer class from server.py
- Class was no longer used after Phase 2

*** DONE Remove --port flag from CLI
CLOSED: [2026-01-21]
- Removed --port CLI option (was for old RunnerServer)
- Removed port parameter from run_local_mode and run_docker_mode
- --api-url remains for flexibility (default: http://localhost:9999)

*** DONE Update README documentation
CLOSED: [2026-01-21]
- Added CRASHED status to TestStatus enum docs
- Updated CLI options (removed --port, documented --api-url)
- Added parallel execution feature
- Added Execution Modes section with config examples
- Added idempotent updates feature

*** DEFERRED Add/update tests
- No existing test infrastructure for tsuite package
- Would require significant effort to set up test framework
- Recommend as future enhancement when time permits

* CLI Workflow (Main Entry Point)

#+begin_src python
def main(suite_path, tc, uc, all_tests, docker, api_url):
    # 1. Ensure API server is running
    api_url = ensure_api_server(api_url or "http://localhost:9999")

    # 2. Load config and discover tests
    config = load_config(suite_path)
    tests = discover_tests(suite_path, tc=tc, uc=uc, all_tests=all_tests)

    # 3. Create run via API
    run_id = create_run(api_url, suite_id, tests)
    emit_run_started(api_url, run_id)

    # 4. Execute tests
    if docker:
        run_docker_mode(tests, config, api_url, run_id)
    else:
        run_local_mode(tests, config, api_url, run_id)

    # 5. Complete run
    complete_run(api_url, run_id)
#+end_src

* Config Schema

#+begin_src yaml
# config.yaml
suite:
  name: "Integration Tests"
  mode: docker  # or standalone

execution:
  max_workers: 4        # Parallel workers (docker mode only)
  timeout: 300          # Per-test timeout in seconds

docker:
  base_image: "tsuite-mesh:latest"
  network: "bridge"

packages:
  mode: "auto"          # local, published, or auto
#+end_src

* File Changes Summary

| File                            | Changes                                       |
|---------------------------------+-----------------------------------------------|
| tsuite/tsuite/server.py         | Add /api/runner/* endpoints, simplify run API |
| tsuite/tsuite/cli.py            | Remove RunnerServer, add API integration      |
| tsuite/tsuite/models.py         | Add CRASHED to TestStatus                     |
| tsuite/tsuite/docker_executor.py| Update SERVER_URL to 9999                     |
| tsuite/tsuite/container_runner.py| Update server URL references                 |
| Config files                    | Add execution.max_workers, execution.timeout  |

* Testing Checklist

- [ ] API server health check works
- [ ] API server auto-starts when CLI runs
- [ ] CLI creates run via API (not pre-created)
- [ ] RunnerServer endpoints work at /api/runner/*
- [ ] Containers can reach API server at host.docker.internal:9999
- [ ] Worker pool executes tests in parallel (docker mode)
- [ ] Standalone mode remains sequential
- [ ] Idempotent status updates (can't overwrite terminal states)
- [ ] Crash detection works (container dies unexpectedly)
- [ ] Timeout handling works
- [ ] SSE events reach dashboard when CLI updates status
- [ ] UI-triggered runs work (eventual consistency)

* Rollback Plan

If issues arise:
1. Keep RunnerServer code commented initially (don't delete)
2. Add --legacy flag to use old dual-server architecture
3. Remove legacy code after stable operation confirmed
